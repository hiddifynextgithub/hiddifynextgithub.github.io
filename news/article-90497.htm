<!DOCTYPE html>
<html xml:lang="zh-CN" lang="zh-CN">

<head>
        <link rel="canonical" href="https://hiddifynextgithub.github.io/news/article-90497.htm" />
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Redis 如何保证数据库和缓存双写一致性？</title>
        <meta name="description" content="前言  数据库和缓存（比如：redis）双写数据一致性问题，是一个跟开发语言无关的公共问题。尤其在高并发的场景下，这个问题变得更加严重。 我很负责的告诉大家，该问题无论在面试，还是工作中遇到的概率非常" />
        <link rel="icon" href="/assets/website/img/hiddifynextgithub/favicon.ico" type="image/x-icon"/>

    <meta name="author" content="HiddifyNextGithub免费节点官网">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://hiddifynextgithub.github.io/news/article-90497.htm" />
    <meta property="og:site_name" content="HiddifyNextGithub免费节点官网" />
    <meta property="og:title" content="Redis 如何保证数据库和缓存双写一致性？" />
    <meta property="og:image" content="https://hiddifynextgithub.github.io/uploads/20240808-2/fb9b9d3bf9f6fe3052768d922859c076.webp" />
        <meta property="og:release_date" content="2025-04-07T09:02:40" />
    <meta property="og:updated_time" content="2025-04-07T09:02:40" />
        <meta property="og:description" content="前言  数据库和缓存（比如：redis）双写数据一致性问题，是一个跟开发语言无关的公共问题。尤其在高并发的场景下，这个问题变得更加严重。 我很负责的告诉大家，该问题无论在面试，还是工作中遇到的概率非常" />
    
    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Redis 如何保证数据库和缓存双写一致性？">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    <link rel="dns-prefetch" href="https://cdn.bootcdn.net">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/Swiper/10.3.1/swiper-bundle.min.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.3.2/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/assets/website/css/hiddifynextgithub/vendor.css">
    <link rel="stylesheet" type="text/css" href="/assets/website/css/hiddifynextgithub/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LL7EDWRR8Q"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LL7EDWRR8Q');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
        <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
        <symbol xmlns="http://www.w3.org/2000/svg" id="navbar-icon" viewBox="0 0 16 16">
            <path d="M14 10.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0 0 1h3a.5.5 0 0 0 .5-.5zm0-3a.5.5 0 0 0-.5-.5h-7a.5.5 0 0 0 0 1h7a.5.5 0 0 0 .5-.5zm0-3a.5.5 0 0 0-.5-.5h-11a.5.5 0 0 0 0 1h11a.5.5 0 0 0 .5-.5z" />
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="facebook" viewBox="0 0 24 24">
            <path fill="currentColor" d="M22 12c0-5.52-4.48-10-10-10S2 6.48 2 12c0 4.84 3.44 8.87 8 9.8V15H8v-3h2V9.5C10 7.57 11.57 6 13.5 6H16v3h-2c-.55 0-1 .45-1 1v2h3v3h-3v6.95c5.05-.5 9-4.76 9-9.95z" />
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="youtube" viewBox="0 0 32 32">
            <path fill="currentColor" d="M29.41 9.26a3.5 3.5 0 0 0-2.47-2.47C24.76 6.2 16 6.2 16 6.2s-8.76 0-10.94.59a3.5 3.5 0 0 0-2.47 2.47A36.13 36.13 0 0 0 2 16a36.13 36.13 0 0 0 .59 6.74a3.5 3.5 0 0 0 2.47 2.47c2.18.59 10.94.59 10.94.59s8.76 0 10.94-.59a3.5 3.5 0 0 0 2.47-2.47A36.13 36.13 0 0 0 30 16a36.13 36.13 0 0 0-.59-6.74ZM13.2 20.2v-8.4l7.27 4.2Z" />
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="instagram" viewBox="0 0 256 256">
            <path fill="currentColor" d="M128 80a48 48 0 1 0 48 48a48.05 48.05 0 0 0-48-48Zm0 80a32 32 0 1 1 32-32a32 32 0 0 1-32 32Zm48-136H80a56.06 56.06 0 0 0-56 56v96a56.06 56.06 0 0 0 56 56h96a56.06 56.06 0 0 0 56-56V80a56.06 56.06 0 0 0-56-56Zm40 152a40 40 0 0 1-40 40H80a40 40 0 0 1-40-40V80a40 40 0 0 1 40-40h96a40 40 0 0 1 40 40ZM192 76a12 12 0 1 1-12-12a12 12 0 0 1 12 12Z" />
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="twitter" viewBox="0 0 24 24">
            <path fill="currentColor" d="M22.46 6c-.77.35-1.6.58-2.46.69c.88-.53 1.56-1.37 1.88-2.38c-.83.5-1.75.85-2.72 1.05C18.37 4.5 17.26 4 16 4c-2.35 0-4.27 1.92-4.27 4.29c0 .34.04.67.11.98C8.28 9.09 5.11 7.38 3 4.79c-.37.63-.58 1.37-.58 2.15c0 1.49.75 2.81 1.91 3.56c-.71 0-1.37-.2-1.95-.5v.03c0 2.08 1.48 3.82 3.44 4.21a4.22 4.22 0 0 1-1.93.07a4.28 4.28 0 0 0 4 2.98a8.521 8.521 0 0 1-5.33 1.84c-.34 0-.68-.02-1.02-.06C3.44 20.29 5.7 21 8.12 21C16 21 20.33 14.46 20.33 8.79c0-.19 0-.37-.01-.56c.84-.6 1.56-1.36 2.14-2.23Z" />
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="linkedin" viewBox="0 0 512 512">
            <path fill="currentColor" d="M444.17 32H70.28C49.85 32 32 46.7 32 66.89v374.72C32 461.91 49.85 480 70.28 480h373.78c20.54 0 35.94-18.21 35.94-38.39V66.89C480.12 46.7 464.6 32 444.17 32Zm-273.3 373.43h-64.18V205.88h64.18ZM141 175.54h-.46c-20.54 0-33.84-15.29-33.84-34.43c0-19.49 13.65-34.42 34.65-34.42s33.85 14.82 34.31 34.42c-.01 19.14-13.31 34.43-34.66 34.43Zm264.43 229.89h-64.18V296.32c0-26.14-9.34-44-32.56-44c-17.74 0-28.24 12-32.91 23.69c-1.75 4.2-2.22 9.92-2.22 15.76v113.66h-64.18V205.88h64.18v27.77c9.34-13.3 23.93-32.44 57.88-32.44c42.13 0 74 27.77 74 87.64Z" />
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="arrow-down" viewBox="0 0 32 32">
            <path fill="currentColor" d="M24.59 16.59L17 24.17V4h-2v20.17l-7.59-7.58L6 18l10 10l10-10l-1.41-1.41z" />
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="cart" viewBox="0 0 512 512">
            <path fill="currentColor" d="M160 96.039v32h304v63.345l-35.5 112.655H149.932L109.932 16H16v32h66.068l40 288.039h329.9L496 196.306V96.039H160zm16.984 272.305a64.073 64.073 0 0 0-64 64a64 64 0 0 0 128 0a64.072 64.072 0 0 0-64-64Zm0 96a32 32 0 1 1 32-32a32.038 32.038 0 0 1-32 32Zm224-96a64.073 64.073 0 0 0-64 64a64 64 0 0 0 128 0a64.072 64.072 0 0 0-64-64Zm0 96a32 32 0 1 1 32-32a32.038 32.038 0 0 1-32 32Z" />
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="balloon" viewBox="0 0 24 24">
            <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="1.5">
                <path d="M8 16.607c1.15.86 2.518 1.38 4 1.393c4.142.034 7.594-3.92 7.56-8.196C19.527 5.53 16.142 2.034 12 2c-4.142-.034-7.473 3.404-7.44 7.68A8.88 8.88 0 0 0 5.244 13" />
                <path d="M15.5 9a3.035 3.035 0 0 0-3-3M12 20.35c.321 0 .482 0 .593-.022c.654-.128 1.051-.772.858-1.39c-.033-.105-.109-.242-.261-.515M12 20.35c-.321 0-.482 0-.593-.022c-.654-.128-1.051-.772-.858-1.39c.033-.105.109-.242.261-.515M12 20.35v2.15" />
            </g>
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="bag-heart" viewBox="0 0 24 24">
            <g fill="none">
                <path fill="currentColor" d="m12 12.191l-.519.542a.75.75 0 0 0 1.038 0L12 12.191Zm-.957 3.675l-.444.604l.444-.604Zm1.914 0l-.444-.605l.444.605Zm-.957.462v.75v-.75Zm-.514-1.067c-.417-.307-.878-.69-1.227-1.093c-.368-.426-.509-.757-.509-.971h-1.5c0 .77.441 1.45.875 1.952c.453.525 1.014.984 1.474 1.321l.887-1.21ZM9.75 13.197c0-.576.263-.827.492-.907c.25-.088.714-.06 1.24.443l1.037-1.083c-.825-.79-1.861-1.096-2.773-.776c-.934.327-1.496 1.226-1.496 2.323h1.5Zm3.65 3.273c.46-.337 1.022-.796 1.475-1.32c.434-.502.875-1.183.875-1.953h-1.5c0 .214-.141.545-.51.971c-.348.403-.809.786-1.226 1.093l.887 1.21Zm2.35-3.273c0-1.097-.563-1.996-1.496-2.323c-.912-.32-1.948-.014-2.773.776l1.038 1.083c.525-.503.989-.531 1.24-.443c.228.08.491.33.491.907h1.5ZM10.6 16.47c.368.27.782.608 1.4.608v-1.5c-.024 0-.04 0-.094-.03a4 4 0 0 1-.42-.287l-.887 1.21Zm1.914-1.21a4 4 0 0 1-.42.289c-.054.029-.07.029-.094.029v1.5c.618 0 1.032-.337 1.4-.608l-.886-1.21Z" />
                <path stroke="currentColor" stroke-linecap="round" stroke-width="1.5" d="M9 6V5a3 3 0 1 1 6 0v1m5.224 6.526c-.586-3.121-.878-4.682-1.99-5.604C17.125 6 15.537 6 12.36 6h-.72c-3.176 0-4.764 0-5.875.922c-1.11.922-1.403 2.483-1.989 5.604c-.823 4.389-1.234 6.583-.034 8.029C4.942 22 7.174 22 11.639 22h.722c4.465 0 6.698 0 7.897-1.445c.696-.84.85-1.93.696-3.555" />
            </g>
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="handiplast" viewBox="0 0 24 24">
            <g fill="none">
                <path stroke="currentColor" stroke-linecap="round" stroke-width="1.5" d="M13.5 7.642L9.071 3.213a4.142 4.142 0 0 0-5.858 5.858L14.93 20.787a4.142 4.142 0 0 0 5.858-5.858l-4.358-4.358" />
                <path stroke="currentColor" stroke-linecap="round" stroke-width="1.5" d="m12 17.858l-2.929 2.929A4.142 4.142 0 0 1 2.596 20m3.546-8l-2.929 2.929c-.322.322-.58.685-.774 1.071M12 6.142l2.929-2.929a4.142 4.142 0 1 1 5.858 5.858L17.857 12" />
                <path fill="currentColor" d="M15.841 12.871a.788.788 0 1 1-1.114 1.114a.788.788 0 0 1 1.114-1.114Zm-3.712-3.712a.787.787 0 1 0-1.114 1.114a.787.787 0 0 0 1.114-1.114Zm4.641 6.497a.787.787 0 1 1-1.114 1.114a.787.787 0 0 1 1.114-1.114ZM9.345 8.23A.788.788 0 1 0 8.23 9.346A.788.788 0 0 0 9.345 8.23Zm3.712 3.713a.787.787 0 1 1-1.113 1.114a.787.787 0 0 1 1.113-1.114Zm.928 2.785a.788.788 0 1 1-1.114 1.113a.788.788 0 0 1 1.114-1.113Zm-3.712-3.713a.787.787 0 1 0-1.114 1.114a.787.787 0 0 0 1.114-1.114Z" />
            </g>
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="star-fill" viewBox="0 0 16 16">
            <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z" />
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="star-empty" viewBox="0 0 16 16">
            <path d="M2.866 14.85c-.078.444.36.791.746.593l4.39-2.256 4.389 2.256c.386.198.824-.149.746-.592l-.83-4.73 3.522-3.356c.33-.314.16-.888-.282-.95l-4.898-.696L8.465.792a.513.513 0 0 0-.927 0L5.354 5.12l-4.898.696c-.441.062-.612.636-.283.95l3.523 3.356-.83 4.73zm4.905-2.767-3.686 1.894.694-3.957a.565.565 0 0 0-.163-.505L1.71 6.745l4.052-.576a.525.525 0 0 0 .393-.288L8 2.223l1.847 3.658a.525.525 0 0 0 .393.288l4.052.575-2.906 2.77a.565.565 0 0 0-.163.506l.694 3.957-3.686-1.894a.503.503 0 0 0-.461 0z" />
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="play" viewBox="0 0 32 32">
            <path fill="currentColor" d="M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28ZM8 6.69v18.62L24.925 16Z" />
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="call-chat" viewBox="0 0 24 24">
            <path fill="currentColor" fill-rule="evenodd" d="M17 2.75a4.25 4.25 0 0 0-3.807 6.142c.16.32.225.71.12 1.102l-.253.946l.946-.253a1.567 1.567 0 0 1 1.102.12A4.25 4.25 0 1 0 17 2.75ZM11.25 7a5.75 5.75 0 1 1 3.19 5.15a.126.126 0 0 0-.04-.013h-.007l-1.112.297a1.4 1.4 0 0 1-1.715-1.714l.298-1.113V9.6a.126.126 0 0 0-.014-.04a5.73 5.73 0 0 1-.6-2.56ZM3.718 4.092c1.226-1.29 3.254-1.049 4.268.385l1.26 1.783c.811 1.147.743 2.74-.225 3.76l-.245.257c0 .002 0 .004-.002.006c-.013.037-.045.152-.013.372c.067.456.418 1.381 1.846 2.884c1.432 1.508 2.3 1.864 2.703 1.929a.608.608 0 0 0 .294-.007l.408-.43c.874-.92 2.236-1.101 3.335-.469l1.91 1.1c1.633.94 2.013 3.239.708 4.613l-1.42 1.495c-.443.467-1.048.866-1.795.94c-1.824.18-6.049-.055-10.478-4.718c-4.134-4.352-4.919-8.137-5.018-9.986c-.049-.914.358-1.697.894-2.261l.544.516l-.544-.516l1.57-1.653Zm3.043 1.25c-.512-.724-1.433-.767-1.956-.217l-1.57 1.653c-.33.349-.505.748-.483 1.148c.08 1.51.731 4.952 4.607 9.033c4.064 4.279 7.809 4.4 9.244 4.258c.283-.028.575-.186.854-.48l1.42-1.495c.614-.645.453-1.808-.368-2.28l-1.91-1.1c-.513-.295-1.114-.204-1.499.202l-.455.48l-.544-.517c.543.517.543.517.542.518l-.001.002l-.003.003l-.007.006l-.014.014a1.003 1.003 0 0 1-.136.112c-.08.057-.186.12-.321.172c-.276.11-.64.168-1.091.095c-.878-.143-2.028-.773-3.55-2.377c-1.528-1.608-2.113-2.807-2.243-3.7c-.067-.454-.014-.817.084-1.092a1.592 1.592 0 0 1 .23-.427l.03-.037l.014-.015l.006-.006l.003-.003l.002-.002s.001-.001.545.515l-.544-.516l.287-.302c.445-.47.51-1.264.088-1.86L6.76 5.342Z" clip-rule="evenodd" />
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="mail" viewBox="0 0 21 21">
            <g fill="none" fill-rule="evenodd" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3.5 6.5v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2h-10a2 2 0 0 0-2 2z" />
                <path d="m5.5 7.5l5 3l5-3" />
            </g>
        </symbol>
        <symbol xmlns="http://www.w3.org/2000/svg" id="location" viewBox="0 0 24 24">
            <path fill="currentColor" fill-rule="evenodd" d="M5.25 7.7c0-3.598 3.059-6.45 6.75-6.45c3.608 0 6.612 2.725 6.745 6.208l.478.16c.463.153.87.289 1.191.439c.348.162.667.37.911.709c.244.338.341.707.385 1.088c.04.353.04.78.04 1.269v5.748c0 .61 0 1.13-.047 1.547c-.05.438-.161.87-.463 1.237a2.25 2.25 0 0 1-.62.525c-.412.237-.855.276-1.296.253c-.42-.022-.933-.107-1.534-.208l-.041-.007c-1.293-.215-1.814-.296-2.322-.254a4.3 4.3 0 0 0-.552.083c-.498.109-.976.342-2.159.933l-.122.061c-1.383.692-2.234 1.118-3.154 1.251c-.276.04-.555.06-.835.06c-.928-.002-1.825-.301-3.28-.786a73.75 73.75 0 0 1-.127-.043l-.384-.128l-.037-.012c-.463-.154-.87-.29-1.191-.44c-.348-.162-.667-.37-.911-.709c-.244-.338-.341-.707-.385-1.088c-.04-.353-.04-.78-.04-1.269v-5.02c0-.786 0-1.448.067-1.967c.07-.542.23-1.072.666-1.47a2.25 2.25 0 0 1 .42-.304c.517-.287 1.07-.27 1.605-.166c.11.021.223.047.342.078c-.066-.446-.1-.89-.1-1.328Zm.499 3.01a9.414 9.414 0 0 0-1.028-.288c-.395-.077-.525-.03-.586.004a.747.747 0 0 0-.14.101c-.053.048-.138.156-.19.556c-.053.41-.055.974-.055 1.825v4.93c0 .539.001.88.03 1.138c.028.238.072.327.112.381c.039.055.109.125.326.226c.236.11.56.219 1.07.39l.384.127c1.624.541 2.279.75 2.936.752c.207 0 .413-.015.617-.044c.65-.094 1.276-.397 2.82-1.17l.093-.046c1.06-.53 1.714-.857 2.417-1.01c.246-.054.496-.092.747-.113c.717-.06 1.432.06 2.593.253l.1.017c.655.109 1.083.18 1.407.196c.312.016.419-.025.471-.055a.749.749 0 0 0 .207-.175c.039-.047.097-.146.132-.456c.037-.323.038-.757.038-1.42v-5.667c0-.539-.001-.88-.03-1.138c-.028-.238-.072-.327-.112-.381c-.039-.055-.109-.125-.326-.226c-.236-.11-.56-.219-1.07-.39l-.06-.019a10.701 10.701 0 0 1-1.335 3.788c-.912 1.568-2.247 2.934-3.92 3.663a3.505 3.505 0 0 1-2.794 0c-1.673-.73-3.008-2.095-3.92-3.663a10.856 10.856 0 0 1-.934-2.087ZM12 2.75c-2.936 0-5.25 2.252-5.25 4.95c0 1.418.437 2.98 1.23 4.341c.791 1.362 1.908 2.47 3.223 3.044c.505.22 1.089.22 1.594 0c1.316-.574 2.432-1.682 3.224-3.044c.792-1.36 1.229-2.923 1.229-4.34c0-2.699-2.314-4.951-5.25-4.951Zm0 4a1.25 1.25 0 1 0 0 2.5a1.25 1.25 0 0 0 0-2.5ZM9.25 8a2.75 2.75 0 1 1 5.5 0a2.75 2.75 0 0 1-5.5 0Z" clip-rule="evenodd" />
        </symbol>
    </svg>
    <header id="header" class="site-header position-fixed z-2 w-100 border-bottom mb-5">
        <nav id="header-nav" class="navbar navbar-expand-lg py-3">
            <div class="container-lg">
                <a class="navbar-brand pb-4" href="/">
                                <span>Hiddify Next Github</span>
                                </a>
                <button class="navbar-toggler d-flex d-lg-none order-3 p-2 border-0 shadow-none bg-white" type="button" data-bs-toggle="offcanvas" data-bs-target="#bdNavbar" aria-controls="bdNavbar" aria-expanded="false" aria-label="Toggle navigation">
                    <svg class="navbar-icon" width="50" height="50">
                        <use xlink:href="#navbar-icon"></use>
                    </svg>
                </button>
                <div class="offcanvas offcanvas-end" tabindex="-1" id="bdNavbar" aria-labelledby="bdNavbarOffcanvasLabel">
                    <div class="offcanvas-header px-4 pb-0">
                        <button type="button" class="btn-close btn-close-black" data-bs-dismiss="offcanvas" aria-label="Close" data-bs-target="#bdNavbar"></button>
                    </div>
                    <div class="offcanvas-body">
                        <ul class="navbar-nav scrollspy-nav justify-content-end flex-grow-1 gap-lg-5 pe-3">
                                                        <li class="nav-item">
                                <a class="nav-link text-dark" href="/">首页</a>
                            </li>
                                                        <li class="nav-item">
                                <a class="nav-link text-dark" href="/free-nodes/">免费节点</a>
                            </li>
                                                        <li class="nav-item">
                                <a class="nav-link text-dark" href="/paid-subscribe/">推荐机场</a>
                            </li>
                                                        <li class="nav-item">
                                <a class="nav-link text-dark" href="/client.htm">客户端</a>
                            </li>
                                                        <li class="nav-item">
                                <a class="nav-link text-dark" href="/news/">新闻资讯</a>
                            </li>
                                                        
                            <span class="scrollspy-indicator"></span>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>
    </header>
    <section id="intro" class="scrollspy-section bg-light" style="background: url(/assets/website/img/hiddifynextgithub/bg-pattern.png) no-repeat;background-size: cover;">
        <div class="container-lg py-5">
            <div class="row justify-content-center py-5">
                <div class="col-lg-10 text-center">
                    <h1 class="display-2 fw-bold mt-5 pt-5">Redis 如何保证数据库和缓存双写一致性？</h1>
                    <nav class="breadcrumb justify-content-center">
                        <a class="breadcrumb-item" href="/">首页</a>
                        <a class="breadcrumb-item" href="/news/">新闻资讯</a>
                        <span class="breadcrumb-item active" aria-current="page">正文</span>
                    </nav>
                </div>
            </div>
        </div>
    </section>
    <section id="why" class="scrollspy-section py-5 my-5">
        <div class="container">
            <div class="row">
                <div class="col-md-9">
                                    <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<div id="content_views" class="htmledit_views"> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">前言</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">数据库和缓存（比如：</span><span style="color:#333333;">redis</span><span style="color:#333333;">）双写数据一致性问题，是一个跟开发语言无关的公共问题。尤其在高并发的场景下，这个问题变得更加严重。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我很负责的告诉大家，该问题无论在面试，还是工作中遇到的概率非常大，所以非常有必要跟大家一起探讨一下。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">今天这篇文章我会从浅入深，跟大家一起聊聊，数据库和缓存双写数据一致性问题常见的解决方案，这些方案中可能存在的坑，以及最优方案是什么。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">1.</span></strong><strong><span style="color:#333333;">常见方案</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">通常情况下，我们使用缓存的主要目的是为了提升查询的性能。大多数情况下，我们是这样使用缓存的：</span><img fetchpriority="high" decoding="async" alt="" height="688" src="http://img.555519.xyz/uploads3/20220821/b13f3922de2d5126ce0f2d01183be98f.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">用户请求过来之后，先查缓存有没有数据，如果有则直接返回。</span></li> <li style="text-align:left;"><span style="color:#333333;">如果缓存没数据，再继续查数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">如果数据库有数据，则将查询出来的数据，放入缓存中，然后返回该数据。</span></li> <li style="text-align:left;"><span style="color:#333333;">如果数据库也没数据，则直接返回空。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这是缓存非常常见的用法。一眼看上去，好像没有啥问题。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但你忽略了一个非常重要的细节：<strong>如果数据库中的某条数据，放入缓存之后，又立马被更新了，那么该如何更新缓存呢？</strong></span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">不更新缓存行不行？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">答：当然不行，如果不更新缓存，在很长的一段时间内（决定于缓存的过期时间），用户请求从缓存中获取到的都可能是旧值，而非数据库的最新值。这不是有数据不一致的问题？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，我们该如何更新缓存呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">目前有以下</span><span style="color:#333333;">4</span><span style="color:#333333;">种方案：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">先写缓存，再写数据库</span></li> <li style="text-align:left;"><span style="color:#333333;">先写数据库，再写缓存</span></li> <li style="text-align:left;"><span style="color:#333333;">先删缓存，再写数据库</span></li> <li style="text-align:left;"><span style="color:#333333;">先写数据库，再删缓存</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">接下来，我们详细说说这</span><span style="color:#333333;">4</span><span style="color:#333333;">种方案。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">2.</span></strong><strong><span style="color:#333333;">先写缓存，再写数据库</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">对于更新缓存的方案，很多人第一个想到的可能是在写操作中直接更新缓存（写缓存），更直接明了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，问题来了：在写操作中，到底是先写缓存，还是先写数据库呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们在这里先聊聊先写缓存，再写数据库的情况，因为它的问题最严重。</span><img decoding="async" alt="" height="416" src="http://img.555519.xyz/uploads3/20220821/09f58fec7e82f29c3421ec9c418951e8.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">某一个用户的每一次写操作，如果刚写完缓存，突然网络出现了异常，导致写数据库失败了。</span></p> <p style="margin-left:0;text-align:left;"><img decoding="async" alt="" height="416" src="http://img.555519.xyz/uploads3/20220821/8dbff0716fa96166b7eeee89c615fe51.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">其结果是缓存更新成了最新数据，但数据库没有，这样缓存中的数据不就变成脏数据了？如果此时该用户的查询请求，正好读取到该数据，就会出现问题，因为该数据在数据库中根本不存在，这个问题非常严重。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们都知道，缓存的主要目的是把数据库的数据临时保存在内存，便于后续的查询，提升查询速度。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但如果某条数据，在数据库中都不存在，你缓存这种</span><span style="color:#333333;">“</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">假数据</span></span><span style="color:#333333;">”</span><span style="color:#333333;">又有啥意义呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">因此，先写缓存，再写数据库的方案是不可取的，在实际工作中用得不多。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">3.</span></strong><strong><span style="color:#333333;">先写数据库，再写缓存</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">既然上面的方案行不通，接下来，聊聊先写数据库，再写缓存的方案，该方案在低并发编程中有人在用（我猜的）。</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="394" src="http://img.555519.xyz/uploads3/20220821/3fda48f4718eb8c35ac3f54892b979aa.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">用户的写操作，先写数据库，再写缓存，可以避免之前</span><span style="color:#333333;">“</span><span style="color:#333333;">假数据</span><span style="color:#333333;">”</span><span style="color:#333333;">的问题。但它却带来了新的问题。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">什么问题呢？</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">3.1</span></strong><strong><span style="color:#333333;">写缓存失败了</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如果把写数据库和写缓存操作，放在同一个事务当中，当写缓存失败了，我们可以把写入数据库的数据进行回滚。</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="406" src="http://img.555519.xyz/uploads3/20220821/04cb2395a578240f067b6b839dc6bc7b.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如果是并发量比较小，对接口性能要求不太高的系统，可以这么玩。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但如果在高并发的业务场景中，写数据库和写缓存，都属于远程操作。为了防止出现大事务，造成的死锁问题，通常建议写数据库和写缓存不要放在同一个事务中。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">也就是说在该方案中，如果写数据库成功了，但写缓存失败了，数据库中已写入的数据不会回滚。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这就会出现：数据库是</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">新数据</span></span><span style="color:#333333;">，而缓存是</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">旧数据</span></span><span style="color:#333333;">，两边</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">数据不一致</span></span><span style="color:#333333;">的情况。</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">3.1</span></strong><strong><span style="color:#333333;">高并发下的问题</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">假设在高并发的场景中，针对同一个用户的同一条数据，有两个写数据请求：</span><span style="color:#333333;">a</span><span style="color:#333333;">和</span><span style="color:#333333;">b</span><span style="color:#333333;">，它们同时请求到业务系统。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">其中请求</span><span style="color:#333333;">a</span><span style="color:#333333;">获取的是旧数据，而请求</span><span style="color:#333333;">b获取的是新数据，如下图所示：</span><img loading="lazy" decoding="async" alt="" height="508" src="http://img.555519.xyz/uploads3/20220821/5cbfd39c881b652d27d3a137eeba0af3.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求a先过来，刚写完了数据库。但由于网络原因，卡顿了一下，还没来得及写缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">这时候请求b过来了，先写了数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">接下来，请求b顺利写了缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">此时，请求a卡顿结束，也写了缓存。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">很显然，在这个过程当中，请求</span><span style="color:#333333;">b</span><span style="color:#333333;">在缓存中的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">新数据</span></span><span style="color:#333333;">，被请求</span><span style="color:#333333;">a</span><span style="color:#333333;">的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">旧数据</span></span><span style="color:#333333;">覆盖了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">也就是说：在高并发场景中，如果多个线程同时执行先写数据库，再写缓存的操作，可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况。</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">3.2</span></strong><strong><span style="color:#333333;">浪费系统资源</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">该方案还有一个比较大的问题就是：每个写操作，写完数据库，会马上写缓存，比较</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">浪费系统资源</span></span><span style="color:#333333;">。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">为什么这么说呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">你可以试想一下，如果写的缓存，并不是简单的数据内容，而是要经过非常复杂的计算得出的最终结果。这样每写一次缓存，都需要经过一次非常复杂的计算，不是非常浪费系统资源吗？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">尤其是</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">cpu</span></span><span style="color:#333333;">和</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">内存</span></span><span style="color:#333333;">资源。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">还有些业务场景比较特殊：</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">写多读少</span></span><span style="color:#333333;">。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如果在这类业务场景中，每个用的写操作，都需要写一次缓存，有点得不偿失。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">由此可见，在高并发的场景中，先写数据库，再写缓存，这套方案问题挺多的，也不太建议使用。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如果你已经用了，赶紧看看踩坑了没？</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">4.</span></strong><strong><span style="color:#333333;">先删缓存，再写数据库</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">通过上面的内容我们得知，如果直接更新缓存的问题很多。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，为何我们不能换一种思路：不去直接</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">更新缓存</span></span><span style="color:#333333;">，而改为</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">删除缓存</span></span><span style="color:#333333;">呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">删除缓存方案，同样有两种：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">先删缓存，再写数据库</span></li> <li style="text-align:left;"><span style="color:#333333;">先写数据库，再删缓存</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们一起先看看：先删缓存，再写数据库的情况。</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="366" src="http://img.555519.xyz/uploads3/20220821/a98c7205f18e8e3b90023e88bf59db56.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">说白了，在用户的写操作中，先执行删除缓存操作，再去写数据库。这套方案，可以是可以，但也会有一样问题。</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">4.1</span></strong><strong><span style="color:#333333;">高并发下的问题</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">假设在高并发的场景中，同一个用户的同一条数据，有一个读数据请求</span><span style="color:#333333;">c</span><span style="color:#333333;">，还有另一个写数据请求</span><span style="color:#333333;">d（一个更新操作），同时请求到业务系统。如下图所示：</span><img loading="lazy" decoding="async" alt="" height="600" src="http://img.555519.xyz/uploads3/20220821/26be493be0b2c015f334acd5dc74f9d2.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求d先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">这时请求c过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求c将数据库中的旧值，更新到缓存中。</span></li> <li style="text-align:left;"><span style="color:#333333;">此时，请求d卡顿结束，把新值写入数据库。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在这个过程当中，请求</span><span style="color:#333333;">d</span><span style="color:#333333;">的新值并没有被请求</span><span style="color:#333333;">c</span><span style="color:#333333;">写入缓存，同样会导致缓存和数据库的数据不一致的情况。更正：图中步骤</span><span style="color:#333333;">7</span><span style="color:#333333;">写入旧值，步骤</span><span style="color:#333333;">9</span><span style="color:#333333;">要删掉。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，这种场景的数据不一致问题，能否解决呢？</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">4.2</span></strong><strong><span style="color:#333333;">缓存双删</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在上面的业务场景中，一个读数据请求，一个写数据请求。当写数据请求把缓存删了之后，读数据请求，可能把当时从数据库查询出来的旧值，写入缓存当中。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">有人说还不好办，请求</span><span style="color:#333333;">d</span><span style="color:#333333;">在写完数据库之后，把缓存重新删一次不就行了？</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="480" src="http://img.555519.xyz/uploads3/20220821/03ba20879d006a017085d65178762977.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这就是我们所说的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">缓存双删</span></span><span style="color:#333333;">，即在写数据库之前删除一次，写完数据库后，再删除一次。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">该方案有个非常关键的地方是：第二次删除缓存，并非立马就删，而是要在一定的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">时间间隔</span></span><span style="color:#333333;">之后。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们再重新回顾一下，高并发下一个读数据请求，一个写数据请求导致数据不一致的产生过程：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求d先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">这时请求c过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求c将数据库中的旧值，更新到缓存中。</span></li> <li style="text-align:left;"><span style="color:#333333;">此时，请求d卡顿结束，把新值写入数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">一段时间之后，比如：500ms，请求d将缓存删除。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这样来看确实可以解决缓存不一致问题。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，为什么一定要间隔一段时间之后，才能删除缓存呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">请求</span><span style="color:#333333;">d</span><span style="color:#333333;">卡顿结束，把新值写入数据库后，请求</span><span style="color:#333333;">c</span><span style="color:#333333;">将数据库中的旧值，更新到缓存中。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">此时，如果请求</span><span style="color:#333333;">d</span><span style="color:#333333;">删除太快，在请求</span><span style="color:#333333;">c</span><span style="color:#333333;">将数据库中的旧值更新到缓存之前，就已经把缓存删除了，这次删除就没任何意义。必须要在请求</span><span style="color:#333333;">c</span><span style="color:#333333;">更新缓存之后，再删除缓存，才能把旧值及时删除了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">所以需要在请求</span><span style="color:#333333;">d</span><span style="color:#333333;">中加一个时间间隔，确保请求</span><span style="color:#333333;">c</span><span style="color:#333333;">，或者类似于请求</span><span style="color:#333333;">c</span><span style="color:#333333;">的其他请求，如果在缓存中设置了旧值，最终都能够被请求</span><span style="color:#333333;">d</span><span style="color:#333333;">删除掉。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">接下来，还有一个问题：如果第二次删除缓存时，删除失败了该怎么办？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这里先留点悬念，后面会详细说。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">5.</span></strong><strong><span style="color:#333333;">先写数据库，再删缓存</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">从前面得知，先删缓存，再写数据库，在并发的情况下，也可能会出现缓存和数据库的数据不一致的情况。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，我们只能寄希望于最后的方案了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">接下来，我们重点看看先写数据库，再删缓存的方案。</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="372" src="http://img.555519.xyz/uploads3/20220821/0cc858241b3170edfa5387f19516f47c.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在高并发的场景中，有一个读数据请求，有一个写数据请求，更新过程如下：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求e先写数据库，由于网络原因卡顿了一下，没有来得及删除缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求f查询缓存，发现缓存中有数据，直接返回该数据。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求e删除缓存。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在这个过程中，只有请求</span><span style="color:#333333;">f</span><span style="color:#333333;">读了一次旧数据，后来旧数据被请求</span><span style="color:#333333;">e</span><span style="color:#333333;">及时删除了，看起来问题不大。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但如果是读数据请求先过来呢？</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求f查询缓存，发现缓存中有数据，直接返回该数据。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求e先写数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求e删除缓存。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这种情况看起来也没问题呀？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">答：对的。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但就怕出现下面这种情况，即缓存自己失效了。如下图所示：</span><img loading="lazy" decoding="async" alt="" height="568" src="http://img.555519.xyz/uploads3/20220821/0a7eb2ef9caeca69ecf10fc906f4e26b.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">缓存过期时间到了，自动失效。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求f查询缓存，发缓存中没有数据，查询数据库的旧值，但由于网络原因卡顿了，没有来得及更新缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求e先写数据库，接着删除了缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求f更新旧值到缓存中。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这时，缓存和数据库的数据同样出现不一致的情况了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但这种情况还是比较少的，需要同时满足以下条件才可以：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">缓存刚好自动失效。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求f从数据库查出旧值，更新缓存的耗时，比请求e写数据库，并且删除缓存的还长。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们都知道查询数据库的速度，一般比写数据库要快，更何况写完数据库，还要删除缓存。所以绝大多数情况下，写数据请求比读数据情况耗时更长。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">由此可见，系统同时满足上述两个条件的概率非常小。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#777777;">推荐大家使用先写数据库，再删缓存的方案，虽说不能</span><span style="color:#777777;">100%</span><span style="color:#777777;">避免数据不一致问题，但出现该问题的概率，相对于其他方案来说是最小的。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但在该方案中，如果删除缓存失败了该怎么办呢？</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">6.</span></strong><strong><span style="color:#333333;">删缓存失败怎么办？</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">其实先写数据库，再删缓存的方案，跟缓存双删的方案一样，有一个共同的风险点，即：如果缓存删除失败了，也会导致缓存和数据库的数据不一致。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，删除缓存失败怎么办呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">答：需要加</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">重试机制</span></span><span style="color:#333333;">。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在接口中如果更新了数据库成功了，但更新缓存失败了，可以立刻重试</span><span style="color:#333333;">3</span><span style="color:#333333;">次。如果其中有任何一次成功，则直接返回成功。如果</span><span style="color:#333333;">3</span><span style="color:#333333;">次都失败了，则写入数据库，准备后续再处理。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">当然，如果你在接口中直接</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">同步重试</span></span><span style="color:#333333;">，该接口并发量比较高的时候，可能有点影响接口性能。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这时，就需要改成</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">异步重试</span></span><span style="color:#333333;">了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">异步重试方式有很多种，比如：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">每次都单独起一个线程，该线程专门做重试的工作。但如果在高并发的场景下，可能会创建太多的线程，导致系统OOM问题，不太建议使用。</span></li> <li style="text-align:left;"><span style="color:#333333;">将重试的任务交给线程池处理，但如果服务器重启，部分数据可能会丢失。</span></li> <li style="text-align:left;"><span style="color:#333333;">将重试数据写表，然后使用elastic-job等定时任务进行重试。</span></li> <li style="text-align:left;"><span style="color:#333333;">将重试的请求写入mq等消息中间件中，在mq的consumer中处理。</span></li> <li style="text-align:left;"><span style="color:#333333;">订阅mysql的binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。</span></li> </ol> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">7.</span></strong><strong><span style="color:#333333;">定时任务</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">使用</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">定时任务重试</span></span><span style="color:#333333;">的具体方案如下：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">当用户操作写完数据库，但删除缓存失败了，需要将用户数据写入重试表中。如下图所示：</span><img loading="lazy" decoding="async" alt="" height="846" src="http://img.555519.xyz/uploads3/20220821/ff3e6bcdc9d8db4fe37e8460ba34a52a.jpg"></li> <li style="text-align:left;"><span style="color:#333333;">在定时任务中，异步读取重试表中的用户数据。重试表需要记录一个重试次数字段，初始值为0。然后重试5次，不断删除缓存，每重试一次该字段值+1。如果其中有任意一次成功了，则返回成功。如果重试了5次，还是失败，则我们需要在重试表中记录一个失败的状态，等待后续进一步处理。</span><img loading="lazy" decoding="async" alt="" height="976" src="http://img.555519.xyz/uploads3/20220821/1971301660f79e4a1785b5c07be84001.jpg"></li> <li style="text-align:left;"><span style="color:#333333;">在高并发场景中，定时任务推荐使用<span style="background-color:#f3f4f4;">elastic-job</span>。相对于xxl-job等定时任务，它可以分片处理，提升处理速度。同时每片的间隔可以设置成：1,2,3,5,7秒等。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">使用定时任务重试的话，有个缺点就是实时性没那么高，对于实时性要求特别高的业务场景，该方案不太适用。但是对于一般场景，还是可以用一用的。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但它有一个很大的优点，即数据是落库的，不会丢数据。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">8. mq</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在高并发的业务场景中，</span><span style="color:#333333;">mq</span><span style="color:#333333;">（消息队列）是必不可少的技术之一。它不仅可以异步解耦，还能削峰填谷。对保证系统的稳定性是非常有意义的。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">mq</span><span style="color:#333333;">的生产者，生产了消息之后，通过指定的</span><span style="color:#333333;">topic</span><span style="color:#333333;">发送到</span><span style="color:#333333;">mq</span><span style="color:#333333;">服务器。然后</span><span style="color:#333333;">mq</span><span style="color:#333333;">的消费者，订阅该</span><span style="color:#333333;">topic</span><span style="color:#333333;">的消息，读取消息数据之后，做业务逻辑处理。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">使用</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">mq</span></span><span style="background-color:#f3f4f4;"><span style="color:#333333;">重试</span></span><span style="color:#333333;">的具体方案如下：</span><img loading="lazy" decoding="async" alt="" height="685" src="http://img.555519.xyz/uploads3/20220821/b6d34f4be2ce6acc6774037b2fc13094.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">当用户操作写完数据库，但删除缓存失败了，产生一条mq消息，发送给mq服务器。</span></li> <li style="text-align:left;"><span style="color:#333333;">mq消费者读取mq消息，重试5次删除缓存。如果其中有任意一次成功了，则返回成功。如果重试了5次，还是失败，则写入<span style="background-color:#f3f4f4;">死信队列</span>中。</span></li> <li style="text-align:left;"><span style="color:#333333;">推荐mq使用<span style="background-color:#f3f4f4;">rocketmq</span>，重试机制和死信队列默认是支持的。使用起来非常方便，而且还支持顺序消息，延迟消息和事务消息等多种业务场景。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">当然在该方案中，删除缓存可以完全走异步。即用户的写操作，在写完数据库之后，不用立刻删除一次缓存。而直接发送</span><span style="color:#333333;">mq</span><span style="color:#333333;">消息，到</span><span style="color:#333333;">mq</span><span style="color:#333333;">服务器，然后有</span><span style="color:#333333;">mq</span><span style="color:#333333;">消费者全权负责删除缓存的任务。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">因为</span><span style="color:#333333;">mq</span><span style="color:#333333;">的实时性还是比较高的，因此改良后的方案也是一种不错的选择。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">9. binlog</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">前面我们聊过的，无论是定时任务，还是</span><span style="color:#333333;">mq</span><span style="color:#333333;">（消息队列），做重试机制，对业务都有一定的侵入性。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在使用定时任务的方案中，需要在业务代码中增加额外逻辑，如果删除缓存失败，需要将数据写入重试表。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">而使用</span><span style="color:#333333;">mq</span><span style="color:#333333;">的方案中，如果删除缓存失败了，需要在业务代码中发送</span><span style="color:#333333;">mq</span><span style="color:#333333;">消息到</span><span style="color:#333333;">mq</span><span style="color:#333333;">服务器。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">其实，还有一种更优雅的实现，即</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">监听</span></span><span style="background-color:#f3f4f4;"><span style="color:#333333;">binlog</span></span><span style="color:#333333;">，比如使用：</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">canal</span></span><span style="color:#333333;">等中间件。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">具体方案如下：</span><img loading="lazy" decoding="async" alt="" height="427" src="http://img.555519.xyz/uploads3/20220821/fce6eba89d6007ed8f3eaf102d2795fa.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">在业务接口中写数据库之后，就不管了，直接返回成功。</span></li> <li style="text-align:left;"><span style="color:#333333;">mysql服务器会自动把变更的数据写入binlog中。</span></li> <li style="text-align:left;"><span style="color:#333333;">binlog订阅者获取变更的数据，然后删除缓存。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这套方案中业务接口确实简化了一些流程，只用关心数据库操作即可，而在</span><span style="color:#333333;">binlog</span><span style="color:#333333;">订阅者中做缓存删除工作。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但如果只是按照图中的方案进行删除缓存，只删除了一次，也可能会失败。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如何解决这个问题呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">答：这就需要加上前面聊过的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">重试机制</span></span><span style="color:#333333;">了。如果删除缓存失败，写入重试表，使用定时任务重试。或者写入</span><span style="color:#333333;">mq</span><span style="color:#333333;">，让</span><span style="color:#333333;">mq</span><span style="color:#333333;">自动重试。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在这里推荐使用</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">mq</span></span><span style="background-color:#f3f4f4;"><span style="color:#333333;">自动重试机制</span></span><span style="color:#333333;">。</span><img loading="lazy" decoding="async" alt="" height="731" src="http://img.555519.xyz/uploads3/20220821/abf407d2d90f60275974a44a1859d372.jpg"><span style="color:#333333;">在binlog</span><span style="color:#333333;">订阅者中如果删除缓存失败，则发送一条</span><span style="color:#333333;">mq</span><span style="color:#333333;">消息到</span><span style="color:#333333;">mq</span><span style="color:#333333;">服务器，在</span><span style="color:#333333;">mq</span><span style="color:#333333;">消费者中自动重试</span><span style="color:#333333;">5</span><span style="color:#333333;">次。如果有任意一次成功，则直接返回成功。如果重试</span><span style="color:#333333;">5</span><span style="color:#333333;">次后还是失败，则该消息自动被放入死信队列，后面可能需要人工介入。</span></p> <p style="margin-left:0;text-align:justify;"> </div> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-90496.htm">MySQL分页查询</a></p>
                                        <p>下一个：<a href="/news/article-90916.htm">Linux 环境Skywalking部署Elasticsearch</a></p>
                                    </div>
                                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/news/article-83984.htm" title="狗粮加工厂是个体还是公司好（狗粮加工厂挣钱吗）">狗粮加工厂是个体还是公司好（狗粮加工厂挣钱吗）</a></li>
                        <li class="py-2"><a href="/news/article-67121.htm" title="领养宠物收费吗（领养宠物免费吗）">领养宠物收费吗（领养宠物免费吗）</a></li>
                        <li class="py-2"><a href="/news/article-69708.htm" title="宠物领养管理系统论文范文大全（宠物领养管理系统论文范文大全）">宠物领养管理系统论文范文大全（宠物领养管理系统论文范文大全）</a></li>
                        <li class="py-2"><a href="/news/article-86144.htm" title="动物注射疫苗简报（动物注射疫苗简报怎么写）">动物注射疫苗简报（动物注射疫苗简报怎么写）</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-3-20-hiddify-next-node-share.htm" title="「3月20日」最高速度18.9M/S，2025年HiddifyNext每天更新免费节点订阅链接">「3月20日」最高速度18.9M/S，2025年HiddifyNext每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-4-2-hiddify-next-windows.htm" title="「4月2日」最高速度22.2M/S，2025年HiddifyNext每天更新免费节点订阅链接">「4月2日」最高速度22.2M/S，2025年HiddifyNext每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-3-21-free-node-subscribe-links.htm" title="「3月21日」最高速度20.5M/S，2025年HiddifyNext每天更新免费节点订阅链接">「3月21日」最高速度20.5M/S，2025年HiddifyNext每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-4-9-free-node-subscribe.htm" title="「4月9日」最高速度18.6M/S，2025年HiddifyNext每天更新免费节点订阅链接">「4月9日」最高速度18.6M/S，2025年HiddifyNext每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/news/article-79093.htm" title="动物疫苗间隔多久打一次比较好一点（动物疫苗接种间隔）">动物疫苗间隔多久打一次比较好一点（动物疫苗接种间隔）</a></li>
                        <li class="py-2"><a href="/news/article-66486.htm" title="豆腐蔬菜条的做法大全">豆腐蔬菜条的做法大全</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">30</span> <a href="/date/2025-04/" title="2025-04 归档">2025-04</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">89</span> <a href="/date/2025-03/" title="2025-03 归档">2025-03</a></h4>
            </li>
                    </ul>
    </div>
</div>

                </div>
            </div>
        </div>
    </section>
        <div class="footer-bottom py-3 text-center">
        <div class="container-lg">
                                <p>
                                                <a href="/">首页</a> |
                                                <a href="/free-nodes/">免费节点</a> |
                                                <a href="/paid-subscribe/">推荐机场</a> |
                                                <a href="/client.htm">客户端</a> |
                                                <a href="/news/">新闻资讯</a> |
                                                <a href="/about-us.htm">关于我们</a> |
                        <a href="/disclaimer.htm">免责申明</a> |
                        <a href="/privacy.htm">隐私申明</a> |
                        <a href="/sitemap.xml">网站地图</a>
                    </p>
            <p class="m-0">
                HiddifyNextGithub免费节点官网 版权所有 Powered by WordPress
            </p>
        </div>
    </div>
    <script src="/assets/website/js/frontend/hiddifynextgithub/jquery-1.11.0.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.3.2/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/Swiper/10.3.1/swiper-bundle.min.js"></script>
    <script src="/assets/website/js/frontend/hiddifynextgithub/plugins.js"></script>
    <script src="/assets/website/js/frontend/hiddifynextgithub/script.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>